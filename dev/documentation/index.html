<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · DeIdentification.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/bcbi.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DeIdentification.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../usage/">Guide</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/bcbi/DeIdentification.jl/blob/master/docs/src/documentation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DeIdentification.DeIdDataFrame-Tuple{DataFrames.DataFrame,Memento.Logger,Array{Symbol,1},Array{Symbol,1},Array{Symbol,1},Array{Symbol,1},Dict{Int64,Int64},Symbol,Dict{Symbol,Dict{String,Int64}},Dict{Any,String}}" href="#DeIdentification.DeIdDataFrame-Tuple{DataFrames.DataFrame,Memento.Logger,Array{Symbol,1},Array{Symbol,1},Array{Symbol,1},Array{Symbol,1},Dict{Int64,Int64},Symbol,Dict{Symbol,Dict{String,Int64}},Dict{Any,String}}"><code>DeIdentification.DeIdDataFrame</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">DeIdDataFrame(df, hash_cols, salt_cols, dateshift_cols, drop_cols, dateshift_dict, id_col, id_dicts, salt)</code></pre><p>This is the constructor for our DeIdDataFrame objects. Note that the <code>id_col</code> is the primary identifier for the dataset and what we use for our lookup in the date-shift dictionary. Also note that the <code>dateshift_dict</code> object stores the Research IDs as the keys, and number of days that the participant (for example) ought to have their dates shifted. The <code>id_dicts</code> argument is a dictionary containing the hash digest of original IDs to our new research IDs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bcbi/DeIdentification.jl/blob/e366bb3f3c4b49a021419716eed40354e6cba904/src/de_identify.jl#L65-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DeIdentification.DeIdentified-Tuple{DeIdConfig}" href="#DeIdentification.DeIdentified-Tuple{DeIdConfig}"><code>DeIdentification.DeIdentified</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">DeIdentified(cfg)</code></pre><p>This is the constructor for the <code>DeIdentified</code> struct. We use this type to store arrays of <code>DeIdDataFrame</code> variables, while also keeping a common <code>salt_dict</code> and <code>dateshift_dict</code> between <code>DeIdDataFrame</code>s. The <code>salt_dict</code> allows us to track what salt was used on what cleartext. This is only necessary in the case of doing re-identification. The <code>id_dicts</code> argument is a dictionary containing other dictionaries that store the hash digest of the original primary IDs to our new research IDs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bcbi/DeIdentification.jl/blob/e366bb3f3c4b49a021419716eed40354e6cba904/src/de_identify.jl#L139-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DeIdentification.deidentify-Tuple{String}" href="#DeIdentification.deidentify-Tuple{String}"><code>DeIdentification.deidentify</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">deidentify(config_path)</code></pre><p>Run entire pipelint: Processes configuration YAML file, de-identifies the data, and writes the data to disk.  Returns the DeIdentified object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bcbi/DeIdentification.jl/blob/e366bb3f3c4b49a021419716eed40354e6cba904/src/de_identify.jl#L191-L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.write-Tuple{DeIdentified}" href="#Base.write-Tuple{DeIdentified}"><code>Base.write</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">write(deid)</code></pre><p>Writes DeIdentified structure to file. The datasets are outputted as CSVs, the dictionaries are written to josn. The files are written to the  <code>output_path</code> specified in the configuration YAML. </p></div></div><a class="source-link" target="_blank" href="https://github.com/bcbi/DeIdentification.jl/blob/e366bb3f3c4b49a021419716eed40354e6cba904/src/exporting.jl#L6-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DeIdentification.dateshift_col!" href="#DeIdentification.dateshift_col!"><code>DeIdentification.dateshift_col!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dateshift_col!(df, date_col, id_col, dateshift_dict)</code></pre><p>This function is used internally by <code>dateshift_all_cols!()</code>. We require that date shifting is done at the patient level. Thus, we pass the <code>id_col</code> to ensure that for a given patient, all their encounter data are shifted by the same <code>n_days</code>.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: The dataframe with the column to be date shifted</li><li><code>date_col::Symbol</code>: Column with dates to be shifted</li><li><code>id_col::Symbol</code>: Column with ID (e.g., patient ID) to find dateshift value for this observation</li><li><code>dateshift_dict::Dict</code>: Dictionary where keys are ID (e.g., patient ID) and values are integers by which to shift the date (i.e., a number of days)</li><li><code>max_days::Int</code>: The maximum number of days (positive or negative) that a date could be shifted</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bcbi/DeIdentification.jl/blob/e366bb3f3c4b49a021419716eed40354e6cba904/src/date_shifting.jl#L10-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DeIdentification.hash_all_columns!-Tuple{DataFrames.DataFrame,Memento.Logger,Array{Symbol,1},Array{Symbol,1},Symbol,Dict{Symbol,Dict{String,Int64}},Dict{Any,String}}" href="#DeIdentification.hash_all_columns!-Tuple{DataFrames.DataFrame,Memento.Logger,Array{Symbol,1},Array{Symbol,1},Symbol,Dict{Symbol,Dict{String,Int64}},Dict{Any,String}}"><code>DeIdentification.hash_all_columns!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hash_all_columns!(df, salt_dict, hash_col_names, salt_col_names)</code></pre><p>This function simply iterates over columns to be hashed, those to be salted and hashed, and those for which we want to generate sane-looking research IDs. Note that the <code>id_dicts</code> nested dictionary stores dictionaries for each column for which we have generated research IDs. Also note that this approach presumes if we have a column (e.g., <code>:ssn</code>) for which we generate a research ID in one dataframe, then all subsequent columns in other dataframes must have the same column name (i.e., <code>:ssn</code>).</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: Dataframe to be de-identified</li><li><code>logger::Memento.Logger</code>: This is our logger that writes logs to disk</li><li><code>hash_col_names::Array{Symbol,1}</code>: Array with names of columns to be hashed</li><li><code>salt_col_names::Array{Symbol,1}</code>: Array with names of columns to be salted <em>and</em> hashed</li><li><code>id_cols::Array{Symbol,1}</code>: Array with names of columns to be turned in to research IDs</li><li><code>id_dicts::Dict{Symbol, Dict{String, Int}}</code>: This is a dictionary of dictionaries. The keys of the outer dictionary are the column names of ID variables. The values of the outer dictionary are dictionaries themselves with key-values being hash digest IDs =&gt; research IDs.</li><li><code>salt_dict::Dict{String, Tuple{String, Symbol}}</code>: Dictionary where key is cleartext, and value is a Tuple with {salt, column name}</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bcbi/DeIdentification.jl/blob/e366bb3f3c4b49a021419716eed40354e6cba904/src/hash_columns.jl#L100-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DeIdentification.hash_column!-Tuple{Any,Symbol}" href="#DeIdentification.hash_column!-Tuple{Any,Symbol}"><code>DeIdentification.hash_column!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hash_column!(df, col_name, salt_dict)</code></pre><p>This function is used to hash columns containing identifiers. Hashing is done in place using SHA256 and a 64-bit salt. Of note is that missing values are left missing.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: The dataframe to be de-idenfied</li><li><code>col_name::Symbol</code>: Name of column to de-idenfy</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bcbi/DeIdentification.jl/blob/e366bb3f3c4b49a021419716eed40354e6cba904/src/hash_columns.jl#L73-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DeIdentification.hash_salt_column!-Tuple{Any,Symbol,Symbol,Dict{Any,String}}" href="#DeIdentification.hash_salt_column!-Tuple{Any,Symbol,Symbol,Dict{Any,String}}"><code>DeIdentification.hash_salt_column!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hash_salt_column!(df, col_name, salt_dict)</code></pre><p>This function is used to salt and hash columns containing unique identifiers. Hashing is done in place using SHA256 and a 64-bit salt. Of note is that missing values are left missing.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: The dataframe to be de-idenfied</li><li><code>col_name::Symbol</code>: Name of column to de-idenfy</li><li><code>salt_dict::Dict{String, Tuple{String, Symbol}}</code>: Dictionary where key is cleartext, and value is a Tuple with {salt, column name}</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bcbi/DeIdentification.jl/blob/e366bb3f3c4b49a021419716eed40354e6cba904/src/hash_columns.jl#L40-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DeIdentification.rid_generation-Tuple{Any,Symbol,Dict{String,Int64}}" href="#DeIdentification.rid_generation-Tuple{Any,Symbol,Dict{String,Int64}}"><code>DeIdentification.rid_generation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rid_generation(df, col_name, id_dict)</code></pre><p>This function is for generating a research ID from a hash digest ID. That is, for those cases in which we want to hash an ID (not salt) and preserve linkages across data sets, it&#39;s nicer to have a numeric value rather than 64-character hash digest to look at. Note that using this function pre-supposes that the rows of the data frame have been shuffled, as we do in the <code>DeIdDataFrame()</code> construnctor. Otherwise, we risk potentially leaking some information related to the order of the observations in the dataframes.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: The de-identified dataframe</li><li><code>col_name::Symbol</code>: The column containing the hash digest of the original ID</li><li><code>id_dict::Dict</code>: Dictionary with hash digest =&gt; research ID mapping</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bcbi/DeIdentification.jl/blob/e366bb3f3c4b49a021419716eed40354e6cba904/src/hash_columns.jl#L3-L17">source</a></section><footer><hr/><a class="previous" href="../usage/"><span class="direction">Previous</span><span class="title">Guide</span></a></footer></article></body></html>
